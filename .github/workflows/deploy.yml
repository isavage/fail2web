name: Deploy to VPS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'prod-IN'
        type: choice
        options:
        - prod-IN
        - prod-NL
      cleanup:
        description: 'Clean up persistent directories before deploying'
        required: false
        type: boolean
        default: false
      use_git_deployment:
        description: 'Dev - git based deployment'
        required: false
        type: boolean
        default: false
      

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for git operations

      - name: Upload files to temporary directory on VPS (SCP mode)
        if: ${{ github.event.inputs.use_git_deployment != 'true' }}
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: 22
          source: ".,!.git*,!.github*,!.gitignore,.env"
          target: "/tmp/fail2web-deploy-temp"
          strip_components: 0
          overwrite: true

      - name: Cleanup (if needed), move files, and finalize deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: 22
          script: |
            set -e

            # Determine target directory based on deployment mode
            USE_GIT="${{ github.event.inputs.use_git_deployment }}"
            if [[ "$USE_GIT" == "true" ]]; then
              TARGET_DIR="/docker/fail2web_dev"
              echo "üîß Dev mode: using $TARGET_DIR directory"
            else
              TARGET_DIR="/docker/fail2web"
              echo "üîß Prod mode: using $TARGET_DIR directory"
            fi
            
            TEMP_DIR="/tmp/fail2web-deploy-temp"
            REPO_URL="https://github.com/${{ github.repository }}.git"
            # Extract branch name from ref (e.g., refs/heads/main -> main)
            CURRENT_BRANCH="${{ github.ref }}"
            CURRENT_BRANCH="${CURRENT_BRANCH#refs/heads/}"

            # Stop any running containers from the OTHER directory first
            PROD_DIR="/docker/fail2web"
            if [ -d "$PROD_DIR" ] && [ -f "$PROD_DIR/docker-compose.yml" ]; then
                echo "üõë Stopping prod containers in $PROD_DIR..."
                cd "$PROD_DIR" && docker compose down 2>/dev/null || true
            fi
            DEV_DIR="/docker/fail2web_dev"
            if [ -d "$DEV_DIR" ] && [ -f "$DEV_DIR/docker-compose.yml" ]; then
                echo "üõë Stopping dev containers in $DEV_DIR..."
                cd "$DEV_DIR" && docker compose down 2>/dev/null || true
            fi

            # Ensure target exists
            mkdir -p "$TARGET_DIR"
            cd "$TARGET_DIR"

            if [[ "$USE_GIT" == "true" ]]; then
              echo "üîß Git-based deployment mode"
              
              # Clean up target directory for fresh git clone
              echo "üßπ Cleaning up $TARGET_DIR for fresh git clone..."
              # Remove all files and directories except . (current directory)
              find . -mindepth 1 -type f -delete 2>/dev/null || true
              find . -mindepth 1 -type d -empty -delete 2>/dev/null || true
              find . -mindepth 1 -type d -exec rm -rf {} + 2>/dev/null || true
              
              # Clone fresh repository
              echo "üì¶ Cloning repository..."
              git clone --branch "$CURRENT_BRANCH" "$REPO_URL" .
              
              # Copy .env from prod if it doesn't exist
              PROD_ENV="/docker/fail2web/.env"
              if [ ! -f .env ] && [ -f "$PROD_ENV" ]; then
                echo "üîí Copying .env from prod directory"
                cp "$PROD_ENV" .env
              elif [ ! -f .env ]; then
                echo "‚ùå .env file missing! Create one manually or copy from prod."
                exit 1
              fi
            else
              echo "üîß Standard SCP deployment mode"
              
              # Backup .env before cleanup (if requested)
              if [[ "${{ github.event.inputs.cleanup }}" == "true" ]]; then
                echo "üßπ Cleanup requested for prod deployment - removing ALL files including fail2ban data"
                if [ -f .env ]; then
                  echo "üîí Backing up .env file (credentials only)"
                  cp .env .env.backup
                fi

                # NEW: Explicitly remove the entire fail2ban/data directory for full reset
                if [ -d fail2ban/data ]; then
                  echo "üóëÔ∏è Removing persistent Fail2ban data (bans DB + custom jails/filters)"
                  rm -rf fail2ban/data
                fi
              
                # Clean up ALL files including fail2ban/data
                # First, remove all files except backups
                find . -mindepth 1 -not -path './*.backup' -type f -delete 2>/dev/null || true
                # Then remove empty directories
                find . -mindepth 1 -not -path './*.backup' -type d -empty -delete 2>/dev/null || true
                # Finally, force remove any remaining directories (including fail2ban/data)
                find . -mindepth 1 -not -path './*.backup' -type d -exec rm -rf {} + 2>/dev/null || true
              fi
              
              # Move files from temp to target (fast, atomic-ish)
              echo "üöö Moving new files to $TARGET_DIR..."
              rsync -av --no-perms --no-owner --no-group --exclude='.env' "$TEMP_DIR"/. ./

              # Clean up temp directory
              rm -rf "$TEMP_DIR"
              
              # Restore .env from backup if cleanup was performed
              if [ -f .env.backup ]; then
                echo "üîí Restoring .env file"
                mv .env.backup .env
              fi
              
            fi

            # Set permissions
            chmod -R 750 . 2>/dev/null || true
            [ -f .env ] && chmod 640 .env

            # Validate
            if [ ! -f .env ]; then
              echo "‚ùå .env file missing!"
              exit 1
            fi

            if [ ! -f docker-compose.yml ]; then
              echo "‚ùå docker-compose.yml missing!"
              exit 1
            fi

            # Validate required environment variables
            for var in FAIL2WEB_USERNAME FAIL2WEB_PASSWORD FAIL2WEB_SECRET_KEY TZ; do
              grep -q "^$var=" .env || { echo "‚ùå Missing $var in .env"; exit 1; }
            done
            echo "‚úÖ .env validated"

            # Restart services
            echo "üöÄ Restarting services..."
            docker compose down || true
            docker compose up -d --build

            # Wait for services to start
            echo "‚è≥ Waiting for services to start..."
            sleep 10

            # Verify services are running
            if ! docker compose ps | grep -q "Up"; then
              echo "‚ùå Services failed to start!"
              docker compose logs
              exit 1
            fi
            echo "‚úÖ Services running"

            if [[ "$USE_GIT" == "true" ]]; then
              echo "üéâ Dev deployment completed successfully in $TARGET_DIR!"
              echo "üí° For future changes:"
              echo "   1. Push changes to GitHub"
              echo "   2. On VPS: cd /docker/fail2web_dev && git pull"
              echo "   3. On VPS: docker compose up -d --build"
            else
              echo "üéâ Prod deployment completed successfully in $TARGET_DIR!"
            fi
